# JOI 2019 4번 Coin Collecting
## 문제
JOI 씨는 그의 수집실에 큰 책상을 가지고 있고, 그 위에는 몇 개의 희귀한 동전이 있다. 책상을 정리하기 위해, 그는 동전들을 재배치할 것이다.

책상은 $2,000,000,001 \times 2,000,000,001$ 격자로 간주할 수 있다. 열은 왼쪽에서 오른쪽으로 $-1,000,000,000$부터 $1,000,000,000$까지 번호가 매겨져 있고, 행은 아래에서 위로 $-1,000,000,000$부터 $1,000,000,000$까지 번호가 매겨져 있다. 열 번호가 $x$이고 행 번호가 $y$인 칸은 $(x, y)$로 표시한다.

동전은 총 $2N$개 있다. 현재 $i$번째 동전$(1 ≤ i ≤ 2N)$은 $(X_i, Y_i)$ 칸에 놓여 있다. JOI 씨의 목표는 각 칸 $(x, y)$에 동전을 하나씩 놓는 것이다. 여기서 $x$와 $y$는 각각 $1 ≤ x ≤ N$과 $1 ≤ y ≤ 2$를 만족한다. 동전이 손상되지 않게 하기 위해, 그가 할 수 있는 유일한 작업은 동전 하나 골라서 인접한 칸(칸끼리 변을 공유할 때만 인접하다고 한다)으로 옮기는 것이다. 어떤 시점에도 여러 개의 동전이 하나의 칸에 놓여 있어도 상관없다. 그는 가능한 한 적은 작업으로 목표를 달성하고 싶다.

동전의 개수와 현재 동전이 놓여 있는 칸이 주어졌을 때, 목표를 달성하기 위해 필요한 작업 횟수의 최솟값을 계산하는 프로그램을 작성하시오.
## 입력
표준 입력에서 다음 데이터를 읽으시오.
> $N$
> $X_1$ $Y_1$
> $\vdots$
> $X_{2N} Y_{2N}$


## 출력
표준 출력의 첫 줄에 답을 출력하시오. 출력은 목표를 달성하기 위해 필요한 최소 작업 횟수를 포함해야 한다.

## 제한
+ $1\leq N\leq 100,000$
+ $-1,000,000,000\leq X_i\leq 1,000,000,000(1\leq i\leq 2N)$
+ $-1,000,000,000\leq Y_i\leq 1,000,000,000(1\leq i\leq 2N)$

## 서브테스크


|번호|배점|제한|
|------|---|---|
|1|8|$N\leq 10$|
|2|29|$N\leq 1,000$|
|3|63|추가적인 제한 조건은 없다.|


## 예제 입력 1

> 3
0 0
0 4
4 0
2 1
2 5
-1 1

## 예제 출력 1

> 15

이 예시 입력에서는 6개의 동전이 아래 그림과 같이 배치되어 있다. 목표는 굵은 선 안에 동전을 모으는 것이다.

<p align="center">  <img width="246" height="247" src="https://upload.acmicpc.net/1cb37f20-3f37-4215-a6f5-64e9f0b5cda6/-/preview/">  </p>

예를 들어, JOI 씨는 다음과 같은 이동으로 15번의 작업으로 목표를 달성할 수 있다.

 - 첫 번째 동전: (0, 0) → (1, 0) → (1, 1) → (1, 2)  
 - 두 번째 동전: (0, 4) → (1, 4) → (1, 3) → (2, 3) → (3, 3) → (3, 2)  
 - 세 번째 동전: (4, 0) → (4, 1) → (3, 1) 
 - 다섯 번째 동전: (2, 5) → (2, 4) → (2, 3) → (2, 2) 
 - 여섯 번째 동전: (-1, 1) →(0, 1) → (1, 1)
 
그가 14번 이하의 작업으로 목표를 달성할 수 없으므로, 15를 출력해야 한다.

## 예제 입력 2

> 4
> 2 1
> 2 1
> 2 1
> 3 1
> 3 1
> 3 1
> 3 1
> 3 1
## 예제 출력 2

> 9

## 예제 입력 3

> 5
1000000000 1000000000
-1000000000 1000000000
-1000000000 -1000000000
1000000000 -1000000000
-1 -5
-2 2
2 8
4 7
-2 5
7 3
## 예제 출력 3

> 8000000029

## 해설
### 서브테스크 1
어느 동전을 어느 칸에 가져갈지 정하면, 그 후에는 동전마다 독립적으로 움직일 수 있다. $(X, Y)$에서 $(x, y)$로의 최소 이동 횟수는 $|x - X| + |y - Y|$로 맨해튼 거리이다. 서브테스크 1은 비트 DP로 해결할 수 있다. 칸의 부분 집합 $S$에 대해 $dp[S]$를 $1, 2, \ldots, |S|$번째 동전을 각각 하나의 칸으로 옮기기 위한 최소 작업 횟수로 정의하자. $O(2^{2N}N)$에 모두 계산할 수 있다.

    foreach S ⊆ (목표 칸의 집합):
	    foreach c ∈ (목표 칸의 집합)\S:
		    dp[S ∪ {c}] := min{dp[S ∪ {c}], dp[S] + (동전 |S| + 1과 칸 c의 거리)}
	return dp[목표 칸의 집합]

비트 DP를 사용하지 않는 풀이는 다음과 같다. 동전 $i, j$를 최종적으로 각각 $(x_i, y_i), (x_j, y_j)$로 이동시킬 때, $x_i<x_j$이고 $y_i=y_j$이면 $X_i<X_j$이다. $X_i > X_j$라면 최종 위치를 교체해도 이동 횟수가 증가하지 않는다는 것을 보일 수 있다. $y = 1$로 가져가는 동전과 $y = 2$로 가져가는 동전으로 나누면, 좌우를 유지한 채로 이동시키면 된다. 상하로 나누는 방법을 모두 시도하면 $O(2^{2N}N)$ 시간으로 풀 수 있다.

### 서브테스크 2
동전을 $X_i$의 오름차순으로 정렬한 후, 동전 $1, 2, \ldots, a + b$ 를 $(1, 1),(2, 1),\ldots,(a, 1),(1, 2),(2, 2)$,$\ldots,(b, 2)$에 1개씩 이동시키기 위한 최소 횟수를 $dp[a][b]$로 정한다. $O(N^2)$에 해결할 수 있다.

    동전을 X를 기준으로 오름차순이 되도록 정렬
    dp[0][0] := 0
    for a = 0 to N:
	    for b = 0 to N:
		    if a + b < 2N:
			    dp[a + 1][b] := min{dp[a + 1][b], dp[a][b]+(동전 a + b + 1과 (a + 1,1) 사이의 거리)}
			    dp[a][b + 1] := min{dp[a][b + 1], dp[a][b]+(동전 a + b + 1과 (b + 1,2) 사이의 거리)}
    return dp[N][N]

### 서브테스크 3
먼저, 각 동전을 목표 칸 중 가장 가까운 칸으로 이동시킨다. $1 ≦ X_i ≦ N, 1 ≦ Y_i ≦ 2$로 간주한다.
수평 이동은 최소로 하면 된다. 수평 이동은 최소로 하면 된다. 다음을 만족하는 최적해가 존재한다.
> 각 $k = 1, 2, . . . , N - 1$에 대해 $1 ≦ X_i ≦ k$가 되는 동전의 개수를 $a_k$라고 할 때, 동전이 $x = k$와 $x = k + 1$ 사이를 가로로 이동하는 횟수는 $|a_k - 2k|$이다.

수평 이동을 최소로 했을 때 수직 이동 횟수를 구하자. 수직 이동은 가급적 오른쪽에서 수행하기로 하면 수직 이동 횟수가 왼쪽부터 순서대로 구해진다. 왼쪽에서부터 그리디하게 필요한 최소한의 수직 이동만 하자. $y = 1$에서는 동전이 남고 $y = 2$에서는 동전이 부족하거나 그 반대의 경우에만 수직 이동을 하면 된다.

각 위치의 이동 횟수를 순서대로 계산하여 $O(N)$ 시간으로 풀 수 있다. $y = 1, 2$에 대해 $(x, y)$에서 $(x + 1, y)$로 가로로 이동하는 동전 개수 $dy$ (음수인 경우 역방향)를 관리한다.

    answer := 각 동전을 가장 가까운 목표 칸으로 이동시키고, 그 때의 이동 횟수
	d1 := 0, d2 := 0
	for x = 1 to N:
		d1 := d1 + ((x, 1)에 있는 동전 개수) − 1
		d2 := d2 + ((x, 2)에 있는 동전 개수) − 1
		if d1 > 0 and 0 > d2:
			t := min{d1, −d2} // (x, 1)에서 (x, 2)로 t회 수직 이동
			answer := answer + t, d1 := d1 − t, d2 := d2 + t
		if d1 < 0 and 0 < d2:
			t := min{−d1, d2} // (x, 2)에서 (x, 1)로 t회 수직 이동
			answer := answer + t, d1 := d1 + t, d2 := d2 − t
		answer := answer + |d1| // (x, 1)과 (x + 1, 1) 사이를 |d1|번 수평 이동
		answer := answer + |d2| // (x, 2)와 (x + 1, 2) 사이를 |d2|회 수 이동
	return answer

여담으로 같은 $y$좌표로 가지 않을 때는 좌우를 유지해야 하는 것은 아니다.
